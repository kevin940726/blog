<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/blog/phenomic.browser.1fa6b69c27aa5b9c2471.css" /><meta data-react-helmet="true" name="generator" content="Phenomic 0.16.2"/><meta data-react-helmet="true" property="og:site_name" content="blog"/><meta data-react-helmet="true" name="twitter:site" content="@"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="Holy Babel! Praise the ES6 Harmony."/><meta data-react-helmet="true" property="og:url" content="https://kevin940726.github.io/blog/posts/Holy-Babel-Praise-the-ES6-Harmony/"/><meta data-react-helmet="true" property="og:description" content="ECMAScript6 簡稱 ES6 或 ES2015 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～ ES6"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="Holy Babel! Praise the ES6 Harmony."/><meta data-react-helmet="true" name="twitter:creator" content="@"/><meta data-react-helmet="true" name="twitter:description" content="ECMAScript6 簡稱 ES6 或 ES2015 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～ ES6"/><meta data-react-helmet="true" name="description" content="ECMAScript6 簡稱 ES6 或 ES2015 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～ ES6"/><title data-react-helmet="true">Holy Babel! Praise the ES6 Harmony.</title></head><body><div id="phenomic"><div class="BQq3Y" data-reactroot="" data-reactid="1" data-react-checksum="-1483268441"><!-- react-empty: 2 --><!-- react-empty: 3 --><style data-reactid="4">@-ms-viewport { width: device-width; }</style><header class="_1xV8A" data-reactid="5"><nav class="_1G2C6" data-reactid="6"><div class="_3ScMt" data-reactid="7"><a class="_2Dqnn" href="/blog/" data-reactid="8">Kai Hao&#x27;s Blog</a></div><div class="_11SHU" data-reactid="9"><!-- react-text: 10 --><!-- /react-text --><a href="https://github.com/kevin940726/blog" target="_blank" class="_2Dqnn" data-reactid="11"><span class="SVGInline" data-reactid="12"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span><!-- react-text: 13 -->GitHub<!-- /react-text --></a></div></nav></header><div class="_1jOjL" data-reactid="14"><div data-reactid="15"><div class="_3APIs" data-reactid="16"><!-- react-empty: 17 --><h1 data-reactid="18">Holy Babel! Praise the ES6 Harmony.</h1><header class="_1-LPx" data-reactid="19"><time data-reactid="20">2016/03/25</time></header><div class="_3VLPm" data-reactid="21"><div data-reactid="22"><div class="phenomic-BodyContainer" data-reactid="23"><p><strong>ECMAScript6</strong> 簡稱 <strong>ES6</strong> 或 <strong>ES2015</strong> 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～</p>
<p><strong>ES6</strong> 的最新進化多了好幾個技能可以學，它們讓 js 變得更加好用，這篇介紹主要涵蓋一下我個人認為比較常用、必學的技能，還有一些使用的時機和方式，讓大家都可以偷學幾招存進招式機裡哦！</p>
<h2 id="prerequirement"><a href="#prerequirement" class="phenomic-HeadingAnchor">#</a>Prerequirement</h2>
<ul>
<li>基本 JavaScript 語法</li>
</ul>
<h2 id="babel"><a href="#babel" class="phenomic-HeadingAnchor">#</a>Babel</h2>
<p>雖然 ES6 是 JavaScript 官方的進化，但是瀏覽器們卻還沒有全部跟上，很多功能都還沒加進去，或是根本沒有加任何功能，要想要搶先使用這些功能就必須先將自己的 code 做一些前處理的編譯，於是就出現了目前最受歡迎的編譯器 <a href="https://babeljs.io/">Babel</a>，它除了可以讓你編譯 ES6 的原始碼以外，還可以編譯 ES7 或一些尚還在提案階段的新功能唷！使用前不妨造訪他們的網站吧，doc 我認為寫得相當清楚詳細。</p>
<p>Babel 在使用的環境和狀況下會有不同的設定方式，以下簡單介紹幾種比較常見的設定方式，其餘在官網都有相當詳盡的說明。</p>
<h3 id="browser-only"><a href="#browser-only" class="phenomic-HeadingAnchor">#</a>Browser-only</h3>
<p>假如一開始學習時沒有使用任何的 bundler system 的話，直接用 <code>&#x3C;script></code> tag 也許是最快最方便的一種方式了，使用方式很簡單，直接在 <code>&#x3C;head></code> 加入 CDN。</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">" https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js"</span>></span><span class="null"></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></code></pre>
<p>之後的 script source 都可以直接使用囉！</p>
<h3 id="nodejs"><a href="#nodejs" class="phenomic-HeadingAnchor">#</a>Node.js</h3>
<p>如果是後端的環境的話根據使用的情況也會有不同的方式，但最基本的還是直接安裝 <code>babel-cli</code> 就可以立即見效。另外要使用一些 ES6 的功能也要安裝 <code>preset-es2015</code>。</p>
<pre><code class="hljs language-bash">$ npm install --save-dev babel-cli babel-preset-es2015</code></pre>
<p>新建一個叫做 <code>.babelrc</code> 的檔案，裡面告訴 Babel 要使用什麼樣的 preset。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// .babelrc</span>
{ <span class="hljs-string">"presets"</span>: [<span class="hljs-string">"es2015"</span>] }</code></pre>
<p>之後 <code>babel</code> 指令可以編譯原始碼，<code>babel-node</code> 可以執行原始碼或進入 REPL 模式。</p>
<pre><code class="hljs language-bash">$ babel src.js -o build.js <span class="hljs-comment"># 將 src.js 編譯成 build.js</span>
$ babel src/ <span class="hljs-_">-d</span> dist/ -w <span class="hljs-comment"># 將 src 目錄底下的 js 都編譯到 dist 目錄底下，且不斷檢查變更</span>
$ babel-node src.js <span class="hljs-comment"># 直接編譯並執行 src.js (相當於 node src.js)</span>
$ babel-node <span class="hljs-comment"># 進入 babel 的 REPL mode (相當於直接執行 node)</span></code></pre>
<p>其中 <code>babel-node</code> 只適合使用在開發階段，正式上線時還是要使用預先編譯過後的版本。</p>
<h3 id="bundler"><a href="#bundler" class="phenomic-HeadingAnchor">#</a>Bundler</h3>
<p>使用像 <code>webpack</code> 或是 <code>browserify</code> 之類的 bundler 時有各式的使用方法，這部分根據使用方式不同會有比較多的變化，請直接參考官網的教學囉 (其實是懶得寫)。</p>
<h2 id="features"><a href="#features" class="phenomic-HeadingAnchor">#</a>Features</h2>
<h3 id="arrows-function"><a href="#arrows-function" class="phenomic-HeadingAnchor">#</a>Arrows function</h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bar</span>) </span>{
    <span class="hljs-comment">// ...</span>
};

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">var</span> foo = (bar) => {
    <span class="hljs-comment">// ...</span>
};</code></pre>
<p><strong>Arrows function</strong> 是一個 function 的 short hand 用法，除了簡化 <strong>function</strong> 的用法以外也會把 parent 的 <code>this</code> 正確的傳入 function 中，這是一個相當實用的功能，在很多情況下都非常好用。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"hello"</span>;

    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name); <span class="hljs-comment">// undefined</span>
    }, <span class="hljs-number">1000</span>);
}

<span class="hljs-comment">// es6</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"hello"</span>;

    setTimeout(() => {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name); <span class="hljs-comment">// hello</span>
    }, <span class="hljs-number">1000</span>);
}</code></pre>
<p>基本的用法簡單上來說是將 <code>function</code> 捨去，並在 arguments 和 function 的開頭 <code>{</code> 之前加入 arrow <code>=></code>，不過其他還有一些簡單的用法分別用在不同的情況。</p>
<p>arguments 的使用方式：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> foo = () => {
    <span class="hljs-comment">// 沒有 argument 的 function</span>
};

<span class="hljs-keyword">var</span> foo = bar => {
    <span class="hljs-comment">// 只有一個 argument 時可以省去括號</span>
};

<span class="hljs-keyword">var</span> foo = (bar, bar2) => {
    <span class="hljs-comment">// 兩個以上時用 , 隔開</span>
};</code></pre>
<p>若沒有太多的步驟要執行，只要簡單的快速回傳值的話可以這麼寫：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> foo = () => bar;
<span class="hljs-comment">// 或</span>
<span class="hljs-keyword">var</span> foo = () => (bar);
<span class="hljs-comment">// 相當於：</span>
<span class="hljs-keyword">var</span> foo = () => {
    <span class="hljs-keyword">return</span> bar;
};

<span class="hljs-comment">// 若要回傳一個 object 也可以這麼寫</span>
<span class="hljs-keyword">var</span> foo = () => ({
    bar: <span class="hljs-string">"bar"</span>
});
<span class="hljs-comment">// 相當於：</span>
<span class="hljs-keyword">var</span> foo = () => {
    <span class="hljs-keyword">return</span> {
        bar: <span class="hljs-string">"bar"</span>
    };
};</code></pre>
<p>簡單來說若要直接回傳值的話可以用小括號表示或直接省略，若是 object 的話因為直接省略會和 function 的 syntax 衝突，所以外面需要包一層小刮號。</p>
<p><strong>Arrows function</strong> 在一般情況下非常好用，除了跟 <strong>functional programming</strong> 非常合以外，其他基本上所有的情況都最好使用 <strong>arrows function</strong> 來取代原本的 function。唯一的例外就是當內部的 <code>this</code> 有特別指定是自己的時候用 <strong>arrows function</strong> 會得到錯誤的值，這在一些針對舊式的 jQuery 的套件上滿常見的，這時候直接改用原本的 function syntax 就可以了。</p>
<h3 id="let--const"><a href="#let--const" class="phenomic-HeadingAnchor">#</a>Let &#x26; Const</h3>
<p><code>let</code> 和 <code>const</code> 是在宣告變數時新的使用方式，原本的 <code>var</code> 是不夠嚴謹的，所以常常會得到意料之外的結果或 bug，<code>let</code> 只存在於你宣告的 block 裡面，可以解決許多問題。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> bar;

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    bar = <span class="hljs-string">"hello"</span>;
})();

<span class="hljs-keyword">var</span> bar = <span class="hljs-string">"world"</span>;

<span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// world</span>

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">let</span> bar;

{
    bar = <span class="hljs-string">"hello"</span>;
};

<span class="hljs-keyword">let</span> bar = <span class="hljs-string">"world"</span>; <span class="hljs-comment">// ERROR! 重複宣告 bar</span></code></pre>
<p>而 <code>const</code> 顧名思義就是一經宣告後就不變的變數，不允許改變也不允許重複宣告，不過對於 Object 和 Array 還是可以新增 key 或值的，只是一樣無法重複宣告。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> bar = <span class="hljs-string">"foo"</span>; <span class="hljs-comment">// const 宣告時一定要給予其值 (廢話)</span>

bar = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// ERROR! 改變了 const 變數</span>

<span class="hljs-keyword">const</span> foo = [<span class="hljs-string">"hello"</span>];
foo.push(<span class="hljs-string">"world"</span>);
<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// ["hello", "world"]</span></code></pre>
<p>至於最佳的使用情況是：<strong>幾乎任何情況，都應該使用 <code>let</code> 來取代 <code>var</code>。</strong> 而且，<strong>唯一的例外是，只要是不曾更改過的定值就優先使用 <code>const</code>。</strong> 簡單來說，所有情況都不應該再出現 <code>var</code> 囉～！<del>RIP <code>var</code> ~2015。</del></p>
<h3 id="template-strings"><a href="#template-strings" class="phenomic-HeadingAnchor">#</a>Template Strings</h3>
<p>原本 js 的 string <code>'</code> 和 <code>"</code> 都可以使用，並無什麼不同，但是卻缺少了一些方便好用的功能，而 <strong>Template strings</strong> 的 <code>`</code> 帶來了解決方案。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> bar = <span class="hljs-string">"hello"</span>;
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">var</span> str = bar + <span class="hljs-string">", "</span> + foo + <span class="hljs-string">"!"</span>; <span class="hljs-comment">// hello, world!</span>

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> bar = <span class="hljs-string">"hello"</span>;
<span class="hljs-keyword">const</span> foo = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">const</span> str = <span class="hljs-string">`<span class="hljs-subst">${bar}</span>, <span class="hljs-subst">${foo}</span>!`</span>; <span class="hljs-comment">// hello, world!</span></code></pre>
<p><code>${}</code>帶來了簡單的方式讓我們可以任意塞變數進去，另外也可以輕易地辦到多行的 string。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> multiline = <span class="hljs-string">"bar foo foo \
bar bar foo"</span>;

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> multiline = <span class="hljs-string">`bar foo foo
bar bar foo`</span>;</code></pre>
<p>這些功能在處理 url 的 get 等等的情況下特別好用，但在一般情況下沒有變數或是多行的需求時是可以用一般的方式的。</p>
<h3 id="default"><a href="#default" class="phenomic-HeadingAnchor">#</a>Default</h3>
<p>原本 js 的 function 不支援 default value，所以常常必須在 function 裡面做類似下面的處理，但有了 default 後就可以直接指定預設的值。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">foo</span>) </span>{
    foo = foo || <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// 注意，這是不夠嚴謹的作法</span>
    <span class="hljs-keyword">return</span> foo;
};

<span class="hljs-built_in">console</span>.log(bar()); <span class="hljs-comment">// hello</span>

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> bar = (foo = <span class="hljs-string">"hello"</span>) => {
    <span class="hljs-keyword">return</span> foo;
};

<span class="hljs-built_in">console</span>.log(bar()); <span class="hljs-comment">// hello</span></code></pre>
<p>原本要寫出正確的 code 常常會寫得很長，而且如果又有很多個變數時更是痛苦，有了 default value 後就方便許多啦！</p>
<h3 id="spread--rest"><a href="#spread--rest" class="phenomic-HeadingAnchor">#</a>Spread &#x26; Rest</h3>
<p>這可能是對一般人來說最神奇的一個新功能，不過實在是非常的好用呀～廢話不多說直接看範例比較好懂。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> foo = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-keyword">const</span> bar = [...foo, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];

<span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span></code></pre>
<p>簡單來說可以想成它把 Array 拆開成一個一個個別的值放進另一個 Array 裡面，然後會自然的很完美的 fit 進去，太神奇了神奇到我都不太會解釋了 XD，多多使用就會習慣了啦～</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 可以隨意放在任何位置</span>
<span class="hljs-keyword">const</span> foo = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> bar = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-built_in">console</span>.log( [...foo, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, ...bar] ); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span>

<span class="hljs-comment">// better Array.push()</span>
<span class="hljs-keyword">const</span> foo = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">const</span> bar = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
bar.push(...foo);
<span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// [1, 2, 3, 4]</span></code></pre>
<p>除了 Array 以外 Object 也是可以使用的，這樣的用法在需要覆蓋原本的 Object 值時非常常用，在 <strong>Redux</strong> 官方中也是推薦這種作法。<strong>不過要在 Object 中使用需要使用 <code>babel-preset-stage-2</code> 的 preset。</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> foo = {
    <span class="hljs-string">"key1"</span>: <span class="hljs-string">"value1"</span>,
    <span class="hljs-string">"key2"</span>: <span class="hljs-string">"value2"</span>
};

<span class="hljs-keyword">const</span> bar = {
    ...foo,
    <span class="hljs-string">"key2"</span>: <span class="hljs-string">"new value"</span>,
    <span class="hljs-string">"key3"</span>: <span class="hljs-string">"value3"</span>
};

<span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// { key1: 'value1', key2: 'new value', key3: 'value3' }</span></code></pre>
<p>在 Object 中使用時放置的時機很重要，<strong>放在後面的會覆蓋掉前面存在過的 key</strong>。</p>
<p>這樣的功能也同樣可以使用在 function 的 arguments 內，而這就是 <strong>Rest</strong>，而這只可以使用在 Array 上。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> foo = (...bar) => {
    <span class="hljs-keyword">return</span> bar.length;
};

<span class="hljs-built_in">console</span>.log(foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 3</span></code></pre>
<p>很神奇地把一個一個分開的 argument 轉成一個 Array 丟給 function 了！如果覺得這東西會太神奇的話就慢慢習慣吧哈哈～不過這已經在許多程式語言中是相當常見的語法了。</p>
<h3 id="destructuring"><a href="#destructuring" class="phenomic-HeadingAnchor">#</a>Destructuring</h3>
<p><em>解構</em> 是一個特殊的語法可以讓你把一個 Array 或 Object 中的值提取出來另存在一個變數裡，這在 <strong>React</strong> 的拿取 <code>props</code> 的過程中也是非常常見的用法。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [bar, foo] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-built_in">console</span>.log(bar, foo); <span class="hljs-comment">// 1, 2</span>

<span class="hljs-keyword">const</span> { bar, foo } = { bar: <span class="hljs-number">1</span>, foo: <span class="hljs-number">2</span> };
<span class="hljs-built_in">console</span>.log(bar, foo); <span class="hljs-comment">// 1, 2</span></code></pre>
<p>另外也可以使用在 function 的 arguments 中。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> bar = ({ foo }) => {
    <span class="hljs-keyword">return</span> foo;
};

<span class="hljs-built_in">console</span>.log( bar({ foo: <span class="hljs-number">1</span> }) ); <span class="hljs-comment">// 1</span></code></pre>
<p>搭配 <strong>Default</strong> 可以有更好的寫法。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> bar = ({ foo, key = <span class="hljs-number">2</span> }) => {
    <span class="hljs-keyword">return</span> foo + key;
};

<span class="hljs-built_in">console</span>.log( bar({ foo: <span class="hljs-number">1</span> }) ); <span class="hljs-comment">// 3</span></code></pre>
<h3 id="enhanced-object-literals"><a href="#enhanced-object-literals" class="phenomic-HeadingAnchor">#</a>Enhanced Object Literals</h3>
<p>在創建 Object 的時候有了更好的方法。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> foo = <span class="hljs-number">1</span>;

<span class="hljs-keyword">const</span> bar = {
    foo,
    sayHi() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hi"</span>);
    },
    [<span class="hljs-string">`item<span class="hljs-subst">${foo}</span>`</span>]: <span class="hljs-string">`value<span class="hljs-subst">${foo}</span>`</span>
};

<span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// { foo: 1, sayHi: [Function: sayHi], item1: 'value1' }</span>
bar.sayHi(); <span class="hljs-comment">// Hi</span></code></pre>
<p>其中 <code>foo</code> 就是 <code>foo: foo</code> 的縮寫，這在使用 Object 時也是很常用的小技巧 (<em>有仔細注意的話會發現上面 Destructuring 的例子就是這個技巧的延伸</em>)。</p>
<h3 id="class"><a href="#class" class="phenomic-HeadingAnchor">#</a>Class</h3>
<p>相信如果有接觸過其他的程式語言的話就會知道 Class 是什麼東西，今天 js 終於也有了它啦～痛哭流涕～。包含了基本的 constructor 和繼承的使用，這裡就不贅述，如果不懂 Class 是什麼的話找一個比較詳細的教學文來看會比較好哦～</p>
<pre><code class="hljs language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>{
    <span class="hljs-keyword">constructor</span>(color) {
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">"car"</span>;
        <span class="hljs-keyword">this</span>.color = color;
    }

    drive() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`GO! My <span class="hljs-subst">${this.color}</span> <span class="hljs-subst">${this.type}</span>!`</span>);
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Taxi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span> </span>{
    <span class="hljs-keyword">constructor</span>(color) {
        <span class="hljs-keyword">super</span>(color);
        <span class="hljs-keyword">this</span>.type = <span class="hljs-string">"taxi"</span>;
    }
}

<span class="hljs-keyword">const</span> taxi = <span class="hljs-keyword">new</span> Taxi(<span class="hljs-string">"yellow"</span>);
taxi.drive(); <span class="hljs-comment">// GO! My yellow taxi!</span></code></pre>
<h3 id="promise"><a href="#promise" class="phenomic-HeadingAnchor">#</a>Promise</h3>
<p>關於 <strong>Promise</strong> 的介紹我已經在先前有寫過一篇簡單的<a href="https://kevin940726.github.io/blog/2016/03/22/I-Promise-you-it-s-going-to-be-great/">介紹文</a>了，歡迎前往觀看～</p>
<h3 id="module-importexport"><a href="#module-importexport" class="phenomic-HeadingAnchor">#</a>Module import/export</h3>
<p>相信如果熟悉 Node.js 的環境的人都知道 <code>require()</code> 是什麼東西，如今在 bundler 的幫助下整個 js 的生態圈都已經 modulize 化了，除了後端，連前端都可以使用 <code>require()</code> 了，不過還是有許多不方便之處，而 es6 的 <code>import</code> 和 <code>export</code> 就是這個問題的很好的解決方案。</p>
<p>首先是 module export 的寫法。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// module.js</span>
<span class="hljs-comment">// es5</span>
<span class="hljs-built_in">module</span>.exports = {
    foo: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"bar"</span>;
    }
};

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    foo() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"bar"</span>;
    }
};</code></pre>
<p>在 import 時。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> Module = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./module.js'</span>);
<span class="hljs-built_in">console</span>.log( Module.foo() ); <span class="hljs-comment">// bar</span>

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">import</span> Module <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;
<span class="hljs-built_in">console</span>.log( Module.foo() ); <span class="hljs-comment">// bar</span>

<span class="hljs-comment">// or</span>
<span class="hljs-keyword">import</span> { foo } <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span>;
<span class="hljs-built_in">console</span>.log( foo() ); <span class="hljs-comment">// bar</span></code></pre>
<p>以上是一些基本的用法，不過還有很多在原本的 module 下比較難處理的用法。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// export</span>
<span class="hljs-keyword">export</span> { name1, name2 };
<span class="hljs-keyword">export</span> { variable1 <span class="hljs-keyword">as</span> name1, variable2 <span class="hljs-keyword">as</span> name2 };
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name1 = foo, name2 = bar;</code></pre>
<p><code>export default</code> 會讓其他檔案在 <code>import</code> 時指定預設的變數或 function。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> name1;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> name1 = foo;</code></pre>
<p>import 時預設會將 <code>export default</code> 的值 import 進來，如果只想要 import 其中的某些值或 method，使用類似 Destructuring 的語法會讓你的 code 更有系統和結構化，聰明的 bundler 會只幫你把需要的東西 import，省去不少空間和載入速度。用 <code>as</code> 來替引入的 module 改名。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// import</span>
<span class="hljs-keyword">import</span> name1 <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>;
<span class="hljs-keyword">import</span> { name1, name2 } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>;
<span class="hljs-keyword">import</span> { variable1 <span class="hljs-keyword">as</span> name1, variable2 <span class="hljs-keyword">as</span> name2 } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>;
<span class="hljs-keyword">import</span> name1, { name2 } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>;</code></pre>
<p>使用 module 的 <code>import</code>/<code>export</code> 短短篇幅可能沒辦法解釋得非常清楚，有使用過的 Node.js 環境或接觸過其他類似語言(如 Python)的人可能比較能夠理解，詳細還是要自己常常使用才會比較清楚整體架構，不過這除了是使用 bundler 的核心價值以外，也有在開發上可以很有系統的做 code splitting 的優點，更好的除錯和大型專案 scale up 時帶來更清楚的架構，不管前後端都已經是不可或缺的一種開發模式了。</p>
<h3 id="others"><a href="#others" class="phenomic-HeadingAnchor">#</a>Others</h3>
<p><strong>ES6</strong> 還有很多很好用的新功能，這裡只簡單介紹幾個我個人比較常用的，還有其他包括 <code>for...of</code>、<code>Map</code>、<code>Set</code>等非常好用的新功能，詳細可以看強者大大的<a href="https://github.com/lukehoban/es6features#readme">整理</a>。</p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>雖然瀏覽器還沒有全數支援所有的新功能，但是使用新的且穩定的功能在新的專案上已經是必然的趨勢，中大型專案如 <a href="https://github.com/reactjs/redux">Redux</a> 和 facebook 的 <a href="https://github.com/facebook/draft-js">draft.js</a> 都是直接使用 babel 撰寫的，所以不要因為好像要做一些特別的設定才能開始就排斥它，認為是一些邪門歪道 (XD)，趕緊跟上潮流才能當最強訓練家啊～不過當然也不建議直接開始使用 ES7 一些還在 stage 階段的功能 (如 async/await 等)，除了相對不穩定以外，未來也很有可能會更改，使用已經確定或是在社群中已經廣為使用的功能吧！</p>
</div></div></div></div></div></div><footer class="_2z9l6" data-reactid="24"><!-- react-text: 25 -->Powered by <!-- /react-text --><a target="_blank" href="https://github.com/MoOx/phenomic#readme" class="tCyG5" data-reactid="26"><span data-reactid="27">&lt;Phenomic /&gt;</span></a><!-- react-text: 28 --> | <!-- /react-text --><!-- react-text: 29 -->© 2016 Kai Hao, unless otherwise noted.<!-- /react-text --></footer></div></div><script>window.__COLLECTION__ = [{"title":"","metaTitle":"Kai Hao's Blog","layout":"Homepage","description":"","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.41216a2f9e87f1859056a5c9aa75c589.json"},{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"layout":"PageLoading","description":"Content here not used, see web_modules/layouts/PageLoading. This page is a demo for loading state. You can safely delete if you want.","__filename":"loading.md","__url":"/loading/","__resourceUrl":"/loading/index.html","__dataUrl":"/loading/index.html.4f959959ceecdafbb30e2e8fd2869cdc.json"},{"title":"Holy Babel! Praise the ES6 Harmony.","layout":"Post","date":"2016-03-24T16:04:28.000Z","tags":"JavaScript","description":"ECMAScript6 簡稱 ES6 或 ES2015 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～ ES6","__filename":"posts/Holy-Babel-Praise-the-ES6-Harmony.md","__url":"/posts/Holy-Babel-Praise-the-ES6-Harmony/","__resourceUrl":"/posts/Holy-Babel-Praise-the-ES6-Harmony/index.html","__dataUrl":"/posts/Holy-Babel-Praise-the-ES6-Harmony/index.html.c3489ec79d739f733fe1ef80849e1b65.json"},{"title":"I Promise you, it's going to be great!","layout":"Post","date":"2016-03-22T14:15:05.000Z","tags":"JavaScript","description":"Promise 是一個 ES6 JavaScript 中的新功能，雖然瀏覽器尚未全部支援，但其實早在很久以前就已經被非常多人使用，除了知名的 bluebird 套件以外，早在 jQuery 時就已經有人使用了，這篇文章會小小介紹 Promise 在 js","__filename":"posts/I-Promise-you-it-s-going-to-be-great.md","__url":"/posts/I-Promise-you-it-s-going-to-be-great/","__resourceUrl":"/posts/I-Promise-you-it-s-going-to-be-great/index.html","__dataUrl":"/posts/I-Promise-you-it-s-going-to-be-great/index.html.7f41271a04cf7b2f988ffa71381651dc.json"}];window.__INITIAL_STATE__ = {"pages":{"/posts/Holy-Babel-Praise-the-ES6-Harmony/":{"head":{"title":"Holy Babel! Praise the ES6 Harmony.","layout":"Post","date":"2016-03-24T16:04:28.000Z","tags":"JavaScript","description":"ECMAScript6 簡稱 ES6 或 ES2015 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～ ES6"},"body":"<p><strong>ECMAScript6</strong> 簡稱 <strong>ES6</strong> 或 <strong>ES2015</strong> 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～</p>\n<p><strong>ES6</strong> 的最新進化多了好幾個技能可以學，它們讓 js 變得更加好用，這篇介紹主要涵蓋一下我個人認為比較常用、必學的技能，還有一些使用的時機和方式，讓大家都可以偷學幾招存進招式機裡哦！</p>\n<h2 id=\"prerequirement\"><a href=\"#prerequirement\" class=\"phenomic-HeadingAnchor\">#</a>Prerequirement</h2>\n<ul>\n<li>基本 JavaScript 語法</li>\n</ul>\n<h2 id=\"babel\"><a href=\"#babel\" class=\"phenomic-HeadingAnchor\">#</a>Babel</h2>\n<p>雖然 ES6 是 JavaScript 官方的進化，但是瀏覽器們卻還沒有全部跟上，很多功能都還沒加進去，或是根本沒有加任何功能，要想要搶先使用這些功能就必須先將自己的 code 做一些前處理的編譯，於是就出現了目前最受歡迎的編譯器 <a href=\"https://babeljs.io/\">Babel</a>，它除了可以讓你編譯 ES6 的原始碼以外，還可以編譯 ES7 或一些尚還在提案階段的新功能唷！使用前不妨造訪他們的網站吧，doc 我認為寫得相當清楚詳細。</p>\n<p>Babel 在使用的環境和狀況下會有不同的設定方式，以下簡單介紹幾種比較常見的設定方式，其餘在官網都有相當詳盡的說明。</p>\n<h3 id=\"browser-only\"><a href=\"#browser-only\" class=\"phenomic-HeadingAnchor\">#</a>Browser-only</h3>\n<p>假如一開始學習時沒有使用任何的 bundler system 的話，直接用 <code>&#x3C;script></code> tag 也許是最快最方便的一種方式了，使用方式很簡單，直接在 <code>&#x3C;head></code> 加入 CDN。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\" https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js\"</span>></span><span class=\"null\"></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></code></pre>\n<p>之後的 script source 都可以直接使用囉！</p>\n<h3 id=\"nodejs\"><a href=\"#nodejs\" class=\"phenomic-HeadingAnchor\">#</a>Node.js</h3>\n<p>如果是後端的環境的話根據使用的情況也會有不同的方式，但最基本的還是直接安裝 <code>babel-cli</code> 就可以立即見效。另外要使用一些 ES6 的功能也要安裝 <code>preset-es2015</code>。</p>\n<pre><code class=\"hljs language-bash\">$ npm install --save-dev babel-cli babel-preset-es2015</code></pre>\n<p>新建一個叫做 <code>.babelrc</code> 的檔案，裡面告訴 Babel 要使用什麼樣的 preset。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// .babelrc</span>\n{ <span class=\"hljs-string\">\"presets\"</span>: [<span class=\"hljs-string\">\"es2015\"</span>] }</code></pre>\n<p>之後 <code>babel</code> 指令可以編譯原始碼，<code>babel-node</code> 可以執行原始碼或進入 REPL 模式。</p>\n<pre><code class=\"hljs language-bash\">$ babel src.js -o build.js <span class=\"hljs-comment\"># 將 src.js 編譯成 build.js</span>\n$ babel src/ <span class=\"hljs-_\">-d</span> dist/ -w <span class=\"hljs-comment\"># 將 src 目錄底下的 js 都編譯到 dist 目錄底下，且不斷檢查變更</span>\n$ babel-node src.js <span class=\"hljs-comment\"># 直接編譯並執行 src.js (相當於 node src.js)</span>\n$ babel-node <span class=\"hljs-comment\"># 進入 babel 的 REPL mode (相當於直接執行 node)</span></code></pre>\n<p>其中 <code>babel-node</code> 只適合使用在開發階段，正式上線時還是要使用預先編譯過後的版本。</p>\n<h3 id=\"bundler\"><a href=\"#bundler\" class=\"phenomic-HeadingAnchor\">#</a>Bundler</h3>\n<p>使用像 <code>webpack</code> 或是 <code>browserify</code> 之類的 bundler 時有各式的使用方法，這部分根據使用方式不同會有比較多的變化，請直接參考官網的教學囉 (其實是懶得寫)。</p>\n<h2 id=\"features\"><a href=\"#features\" class=\"phenomic-HeadingAnchor\">#</a>Features</h2>\n<h3 id=\"arrows-function\"><a href=\"#arrows-function\" class=\"phenomic-HeadingAnchor\">#</a>Arrows function</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">bar</span>) </span>{\n    <span class=\"hljs-comment\">// ...</span>\n};\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">var</span> foo = (bar) => {\n    <span class=\"hljs-comment\">// ...</span>\n};</code></pre>\n<p><strong>Arrows function</strong> 是一個 function 的 short hand 用法，除了簡化 <strong>function</strong> 的用法以外也會把 parent 的 <code>this</code> 正確的傳入 function 中，這是一個相當實用的功能，在很多情況下都非常好用。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">\"hello\"</span>;\n\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name); <span class=\"hljs-comment\">// undefined</span>\n    }, <span class=\"hljs-number\">1000</span>);\n}\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-string\">\"hello\"</span>;\n\n    setTimeout(() => {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name); <span class=\"hljs-comment\">// hello</span>\n    }, <span class=\"hljs-number\">1000</span>);\n}</code></pre>\n<p>基本的用法簡單上來說是將 <code>function</code> 捨去，並在 arguments 和 function 的開頭 <code>{</code> 之前加入 arrow <code>=></code>，不過其他還有一些簡單的用法分別用在不同的情況。</p>\n<p>arguments 的使用方式：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> foo = () => {\n    <span class=\"hljs-comment\">// 沒有 argument 的 function</span>\n};\n\n<span class=\"hljs-keyword\">var</span> foo = bar => {\n    <span class=\"hljs-comment\">// 只有一個 argument 時可以省去括號</span>\n};\n\n<span class=\"hljs-keyword\">var</span> foo = (bar, bar2) => {\n    <span class=\"hljs-comment\">// 兩個以上時用 , 隔開</span>\n};</code></pre>\n<p>若沒有太多的步驟要執行，只要簡單的快速回傳值的話可以這麼寫：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> foo = () => bar;\n<span class=\"hljs-comment\">// 或</span>\n<span class=\"hljs-keyword\">var</span> foo = () => (bar);\n<span class=\"hljs-comment\">// 相當於：</span>\n<span class=\"hljs-keyword\">var</span> foo = () => {\n    <span class=\"hljs-keyword\">return</span> bar;\n};\n\n<span class=\"hljs-comment\">// 若要回傳一個 object 也可以這麼寫</span>\n<span class=\"hljs-keyword\">var</span> foo = () => ({\n    bar: <span class=\"hljs-string\">\"bar\"</span>\n});\n<span class=\"hljs-comment\">// 相當於：</span>\n<span class=\"hljs-keyword\">var</span> foo = () => {\n    <span class=\"hljs-keyword\">return</span> {\n        bar: <span class=\"hljs-string\">\"bar\"</span>\n    };\n};</code></pre>\n<p>簡單來說若要直接回傳值的話可以用小括號表示或直接省略，若是 object 的話因為直接省略會和 function 的 syntax 衝突，所以外面需要包一層小刮號。</p>\n<p><strong>Arrows function</strong> 在一般情況下非常好用，除了跟 <strong>functional programming</strong> 非常合以外，其他基本上所有的情況都最好使用 <strong>arrows function</strong> 來取代原本的 function。唯一的例外就是當內部的 <code>this</code> 有特別指定是自己的時候用 <strong>arrows function</strong> 會得到錯誤的值，這在一些針對舊式的 jQuery 的套件上滿常見的，這時候直接改用原本的 function syntax 就可以了。</p>\n<h3 id=\"let--const\"><a href=\"#let--const\" class=\"phenomic-HeadingAnchor\">#</a>Let &#x26; Const</h3>\n<p><code>let</code> 和 <code>const</code> 是在宣告變數時新的使用方式，原本的 <code>var</code> 是不夠嚴謹的，所以常常會得到意料之外的結果或 bug，<code>let</code> 只存在於你宣告的 block 裡面，可以解決許多問題。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> bar;\n\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    bar = <span class=\"hljs-string\">\"hello\"</span>;\n})();\n\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-string\">\"world\"</span>;\n\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// world</span>\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">let</span> bar;\n\n{\n    bar = <span class=\"hljs-string\">\"hello\"</span>;\n};\n\n<span class=\"hljs-keyword\">let</span> bar = <span class=\"hljs-string\">\"world\"</span>; <span class=\"hljs-comment\">// ERROR! 重複宣告 bar</span></code></pre>\n<p>而 <code>const</code> 顧名思義就是一經宣告後就不變的變數，不允許改變也不允許重複宣告，不過對於 Object 和 Array 還是可以新增 key 或值的，只是一樣無法重複宣告。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-string\">\"foo\"</span>; <span class=\"hljs-comment\">// const 宣告時一定要給予其值 (廢話)</span>\n\nbar = <span class=\"hljs-string\">\"hello\"</span>; <span class=\"hljs-comment\">// ERROR! 改變了 const 變數</span>\n\n<span class=\"hljs-keyword\">const</span> foo = [<span class=\"hljs-string\">\"hello\"</span>];\nfoo.push(<span class=\"hljs-string\">\"world\"</span>);\n<span class=\"hljs-built_in\">console</span>.log(foo); <span class=\"hljs-comment\">// [\"hello\", \"world\"]</span></code></pre>\n<p>至於最佳的使用情況是：<strong>幾乎任何情況，都應該使用 <code>let</code> 來取代 <code>var</code>。</strong> 而且，<strong>唯一的例外是，只要是不曾更改過的定值就優先使用 <code>const</code>。</strong> 簡單來說，所有情況都不應該再出現 <code>var</code> 囉～！<del>RIP <code>var</code> ~2015。</del></p>\n<h3 id=\"template-strings\"><a href=\"#template-strings\" class=\"phenomic-HeadingAnchor\">#</a>Template Strings</h3>\n<p>原本 js 的 string <code>'</code> 和 <code>\"</code> 都可以使用，並無什麼不同，但是卻缺少了一些方便好用的功能，而 <strong>Template strings</strong> 的 <code>`</code> 帶來了解決方案。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-string\">\"hello\"</span>;\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">\"world\"</span>;\n<span class=\"hljs-keyword\">var</span> str = bar + <span class=\"hljs-string\">\", \"</span> + foo + <span class=\"hljs-string\">\"!\"</span>; <span class=\"hljs-comment\">// hello, world!</span>\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-string\">\"hello\"</span>;\n<span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">\"world\"</span>;\n<span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${bar}</span>, <span class=\"hljs-subst\">${foo}</span>!`</span>; <span class=\"hljs-comment\">// hello, world!</span></code></pre>\n<p><code>${}</code>帶來了簡單的方式讓我們可以任意塞變數進去，另外也可以輕易地辦到多行的 string。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> multiline = <span class=\"hljs-string\">\"bar foo foo \\\nbar bar foo\"</span>;\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> multiline = <span class=\"hljs-string\">`bar foo foo\nbar bar foo`</span>;</code></pre>\n<p>這些功能在處理 url 的 get 等等的情況下特別好用，但在一般情況下沒有變數或是多行的需求時是可以用一般的方式的。</p>\n<h3 id=\"default\"><a href=\"#default\" class=\"phenomic-HeadingAnchor\">#</a>Default</h3>\n<p>原本 js 的 function 不支援 default value，所以常常必須在 function 裡面做類似下面的處理，但有了 default 後就可以直接指定預設的值。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">foo</span>) </span>{\n    foo = foo || <span class=\"hljs-string\">\"hello\"</span>; <span class=\"hljs-comment\">// 注意，這是不夠嚴謹的作法</span>\n    <span class=\"hljs-keyword\">return</span> foo;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(bar()); <span class=\"hljs-comment\">// hello</span>\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> bar = (foo = <span class=\"hljs-string\">\"hello\"</span>) => {\n    <span class=\"hljs-keyword\">return</span> foo;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(bar()); <span class=\"hljs-comment\">// hello</span></code></pre>\n<p>原本要寫出正確的 code 常常會寫得很長，而且如果又有很多個變數時更是痛苦，有了 default value 後就方便許多啦！</p>\n<h3 id=\"spread--rest\"><a href=\"#spread--rest\" class=\"phenomic-HeadingAnchor\">#</a>Spread &#x26; Rest</h3>\n<p>這可能是對一般人來說最神奇的一個新功能，不過實在是非常的好用呀～廢話不多說直接看範例比較好懂。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n\n<span class=\"hljs-keyword\">const</span> bar = [...foo, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span></code></pre>\n<p>簡單來說可以想成它把 Array 拆開成一個一個個別的值放進另一個 Array 裡面，然後會自然的很完美的 fit 進去，太神奇了神奇到我都不太會解釋了 XD，多多使用就會習慣了啦～</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 可以隨意放在任何位置</span>\n<span class=\"hljs-keyword\">const</span> foo = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-keyword\">const</span> bar = [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>];\n<span class=\"hljs-built_in\">console</span>.log( [...foo, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, ...bar] ); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span>\n\n<span class=\"hljs-comment\">// better Array.push()</span>\n<span class=\"hljs-keyword\">const</span> foo = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n<span class=\"hljs-keyword\">const</span> bar = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\nbar.push(...foo);\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// [1, 2, 3, 4]</span></code></pre>\n<p>除了 Array 以外 Object 也是可以使用的，這樣的用法在需要覆蓋原本的 Object 值時非常常用，在 <strong>Redux</strong> 官方中也是推薦這種作法。<strong>不過要在 Object 中使用需要使用 <code>babel-preset-stage-2</code> 的 preset。</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = {\n    <span class=\"hljs-string\">\"key1\"</span>: <span class=\"hljs-string\">\"value1\"</span>,\n    <span class=\"hljs-string\">\"key2\"</span>: <span class=\"hljs-string\">\"value2\"</span>\n};\n\n<span class=\"hljs-keyword\">const</span> bar = {\n    ...foo,\n    <span class=\"hljs-string\">\"key2\"</span>: <span class=\"hljs-string\">\"new value\"</span>,\n    <span class=\"hljs-string\">\"key3\"</span>: <span class=\"hljs-string\">\"value3\"</span>\n};\n\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// { key1: 'value1', key2: 'new value', key3: 'value3' }</span></code></pre>\n<p>在 Object 中使用時放置的時機很重要，<strong>放在後面的會覆蓋掉前面存在過的 key</strong>。</p>\n<p>這樣的功能也同樣可以使用在 function 的 arguments 內，而這就是 <strong>Rest</strong>，而這只可以使用在 Array 上。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = (...bar) => {\n    <span class=\"hljs-keyword\">return</span> bar.length;\n};\n\n<span class=\"hljs-built_in\">console</span>.log(foo(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 3</span></code></pre>\n<p>很神奇地把一個一個分開的 argument 轉成一個 Array 丟給 function 了！如果覺得這東西會太神奇的話就慢慢習慣吧哈哈～不過這已經在許多程式語言中是相當常見的語法了。</p>\n<h3 id=\"destructuring\"><a href=\"#destructuring\" class=\"phenomic-HeadingAnchor\">#</a>Destructuring</h3>\n<p><em>解構</em> 是一個特殊的語法可以讓你把一個 Array 或 Object 中的值提取出來另存在一個變數裡，這在 <strong>React</strong> 的拿取 <code>props</code> 的過程中也是非常常見的用法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> [bar, foo] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n<span class=\"hljs-built_in\">console</span>.log(bar, foo); <span class=\"hljs-comment\">// 1, 2</span>\n\n<span class=\"hljs-keyword\">const</span> { bar, foo } = { bar: <span class=\"hljs-number\">1</span>, foo: <span class=\"hljs-number\">2</span> };\n<span class=\"hljs-built_in\">console</span>.log(bar, foo); <span class=\"hljs-comment\">// 1, 2</span></code></pre>\n<p>另外也可以使用在 function 的 arguments 中。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> bar = ({ foo }) => {\n    <span class=\"hljs-keyword\">return</span> foo;\n};\n\n<span class=\"hljs-built_in\">console</span>.log( bar({ foo: <span class=\"hljs-number\">1</span> }) ); <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>搭配 <strong>Default</strong> 可以有更好的寫法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> bar = ({ foo, key = <span class=\"hljs-number\">2</span> }) => {\n    <span class=\"hljs-keyword\">return</span> foo + key;\n};\n\n<span class=\"hljs-built_in\">console</span>.log( bar({ foo: <span class=\"hljs-number\">1</span> }) ); <span class=\"hljs-comment\">// 3</span></code></pre>\n<h3 id=\"enhanced-object-literals\"><a href=\"#enhanced-object-literals\" class=\"phenomic-HeadingAnchor\">#</a>Enhanced Object Literals</h3>\n<p>在創建 Object 的時候有了更好的方法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-keyword\">const</span> bar = {\n    foo,\n    sayHi() {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Hi\"</span>);\n    },\n    [<span class=\"hljs-string\">`item<span class=\"hljs-subst\">${foo}</span>`</span>]: <span class=\"hljs-string\">`value<span class=\"hljs-subst\">${foo}</span>`</span>\n};\n\n<span class=\"hljs-built_in\">console</span>.log(bar); <span class=\"hljs-comment\">// { foo: 1, sayHi: [Function: sayHi], item1: 'value1' }</span>\nbar.sayHi(); <span class=\"hljs-comment\">// Hi</span></code></pre>\n<p>其中 <code>foo</code> 就是 <code>foo: foo</code> 的縮寫，這在使用 Object 時也是很常用的小技巧 (<em>有仔細注意的話會發現上面 Destructuring 的例子就是這個技巧的延伸</em>)。</p>\n<h3 id=\"class\"><a href=\"#class\" class=\"phenomic-HeadingAnchor\">#</a>Class</h3>\n<p>相信如果有接觸過其他的程式語言的話就會知道 Class 是什麼東西，今天 js 終於也有了它啦～痛哭流涕～。包含了基本的 constructor 和繼承的使用，這裡就不贅述，如果不懂 Class 是什麼的話找一個比較詳細的教學文來看會比較好哦～</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Car</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(color) {\n        <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">\"car\"</span>;\n        <span class=\"hljs-keyword\">this</span>.color = color;\n    }\n\n    drive() {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`GO! My <span class=\"hljs-subst\">${this.color}</span> <span class=\"hljs-subst\">${this.type}</span>!`</span>);\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Taxi</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Car</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(color) {\n        <span class=\"hljs-keyword\">super</span>(color);\n        <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">\"taxi\"</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">const</span> taxi = <span class=\"hljs-keyword\">new</span> Taxi(<span class=\"hljs-string\">\"yellow\"</span>);\ntaxi.drive(); <span class=\"hljs-comment\">// GO! My yellow taxi!</span></code></pre>\n<h3 id=\"promise\"><a href=\"#promise\" class=\"phenomic-HeadingAnchor\">#</a>Promise</h3>\n<p>關於 <strong>Promise</strong> 的介紹我已經在先前有寫過一篇簡單的<a href=\"https://kevin940726.github.io/blog/2016/03/22/I-Promise-you-it-s-going-to-be-great/\">介紹文</a>了，歡迎前往觀看～</p>\n<h3 id=\"module-importexport\"><a href=\"#module-importexport\" class=\"phenomic-HeadingAnchor\">#</a>Module import/export</h3>\n<p>相信如果熟悉 Node.js 的環境的人都知道 <code>require()</code> 是什麼東西，如今在 bundler 的幫助下整個 js 的生態圈都已經 modulize 化了，除了後端，連前端都可以使用 <code>require()</code> 了，不過還是有許多不方便之處，而 es6 的 <code>import</code> 和 <code>export</code> 就是這個問題的很好的解決方案。</p>\n<p>首先是 module export 的寫法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// module.js</span>\n<span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-built_in\">module</span>.exports = {\n    foo: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"bar\"</span>;\n    }\n};\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    foo() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"bar\"</span>;\n    }\n};</code></pre>\n<p>在 import 時。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> Module = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./module.js'</span>);\n<span class=\"hljs-built_in\">console</span>.log( Module.foo() ); <span class=\"hljs-comment\">// bar</span>\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">import</span> Module <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module'</span>;\n<span class=\"hljs-built_in\">console</span>.log( Module.foo() ); <span class=\"hljs-comment\">// bar</span>\n\n<span class=\"hljs-comment\">// or</span>\n<span class=\"hljs-keyword\">import</span> { foo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module'</span>;\n<span class=\"hljs-built_in\">console</span>.log( foo() ); <span class=\"hljs-comment\">// bar</span></code></pre>\n<p>以上是一些基本的用法，不過還有很多在原本的 module 下比較難處理的用法。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// export</span>\n<span class=\"hljs-keyword\">export</span> { name1, name2 };\n<span class=\"hljs-keyword\">export</span> { variable1 <span class=\"hljs-keyword\">as</span> name1, variable2 <span class=\"hljs-keyword\">as</span> name2 };\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> name1 = foo, name2 = bar;</code></pre>\n<p><code>export default</code> 會讓其他檔案在 <code>import</code> 時指定預設的變數或 function。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> name1;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">const</span> name1 = foo;</code></pre>\n<p>import 時預設會將 <code>export default</code> 的值 import 進來，如果只想要 import 其中的某些值或 method，使用類似 Destructuring 的語法會讓你的 code 更有系統和結構化，聰明的 bundler 會只幫你把需要的東西 import，省去不少空間和載入速度。用 <code>as</code> 來替引入的 module 改名。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// import</span>\n<span class=\"hljs-keyword\">import</span> name1 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;\n<span class=\"hljs-keyword\">import</span> { name1, name2 } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;\n<span class=\"hljs-keyword\">import</span> { variable1 <span class=\"hljs-keyword\">as</span> name1, variable2 <span class=\"hljs-keyword\">as</span> name2 } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;\n<span class=\"hljs-keyword\">import</span> name1, { name2 } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'module'</span>;</code></pre>\n<p>使用 module 的 <code>import</code>/<code>export</code> 短短篇幅可能沒辦法解釋得非常清楚，有使用過的 Node.js 環境或接觸過其他類似語言(如 Python)的人可能比較能夠理解，詳細還是要自己常常使用才會比較清楚整體架構，不過這除了是使用 bundler 的核心價值以外，也有在開發上可以很有系統的做 code splitting 的優點，更好的除錯和大型專案 scale up 時帶來更清楚的架構，不管前後端都已經是不可或缺的一種開發模式了。</p>\n<h3 id=\"others\"><a href=\"#others\" class=\"phenomic-HeadingAnchor\">#</a>Others</h3>\n<p><strong>ES6</strong> 還有很多很好用的新功能，這裡只簡單介紹幾個我個人比較常用的，還有其他包括 <code>for...of</code>、<code>Map</code>、<code>Set</code>等非常好用的新功能，詳細可以看強者大大的<a href=\"https://github.com/lukehoban/es6features#readme\">整理</a>。</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>雖然瀏覽器還沒有全數支援所有的新功能，但是使用新的且穩定的功能在新的專案上已經是必然的趨勢，中大型專案如 <a href=\"https://github.com/reactjs/redux\">Redux</a> 和 facebook 的 <a href=\"https://github.com/facebook/draft-js\">draft.js</a> 都是直接使用 babel 撰寫的，所以不要因為好像要做一些特別的設定才能開始就排斥它，認為是一些邪門歪道 (XD)，趕緊跟上潮流才能當最強訓練家啊～不過當然也不建議直接開始使用 ES7 一些還在 stage 階段的功能 (如 async/await 等)，除了相對不穩定以外，未來也很有可能會更改，使用已經確定或是在社群中已經廣為使用的功能吧！</p>\n","__filename":"posts/Holy-Babel-Praise-the-ES6-Harmony.md","__url":"/posts/Holy-Babel-Praise-the-ES6-Harmony/","__resourceUrl":"/posts/Holy-Babel-Praise-the-ES6-Harmony/index.html","__dataUrl":"/posts/Holy-Babel-Praise-the-ES6-Harmony/index.html.c3489ec79d739f733fe1ef80849e1b65.json","type":"Post"}}}</script><script data-react-helmet="true" src="https://cdn.polyfill.io/v2/polyfill.min.js"></script><script src="/blog/phenomic.browser.1fa6b69c27aa5b9c2471.js"></script></body></html>