<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/blog/phenomic.browser.1fa6b69c27aa5b9c2471.css" /><meta data-react-helmet="true" name="generator" content="Phenomic 0.16.2"/><meta data-react-helmet="true" property="og:site_name" content="blog"/><meta data-react-helmet="true" name="twitter:site" content="@"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="I Promise you, it&#x27;s going to be great!"/><meta data-react-helmet="true" property="og:url" content="https://kevin940726.github.io/blog/posts/I-Promise-you-it-s-going-to-be-great/"/><meta data-react-helmet="true" property="og:description" content="Promise 是一個 ES6 JavaScript 中的新功能，雖然瀏覽器尚未全部支援，但其實早在很久以前就已經被非常多人使用，除了知名的 bluebird 套件以外，早在 jQuery 時就已經有人使用了，這篇文章會小小介紹 Promise 在 js"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="I Promise you, it&#x27;s going to be great!"/><meta data-react-helmet="true" name="twitter:creator" content="@"/><meta data-react-helmet="true" name="twitter:description" content="Promise 是一個 ES6 JavaScript 中的新功能，雖然瀏覽器尚未全部支援，但其實早在很久以前就已經被非常多人使用，除了知名的 bluebird 套件以外，早在 jQuery 時就已經有人使用了，這篇文章會小小介紹 Promise 在 js"/><meta data-react-helmet="true" name="description" content="Promise 是一個 ES6 JavaScript 中的新功能，雖然瀏覽器尚未全部支援，但其實早在很久以前就已經被非常多人使用，除了知名的 bluebird 套件以外，早在 jQuery 時就已經有人使用了，這篇文章會小小介紹 Promise 在 js"/><title data-react-helmet="true">I Promise you, it&#x27;s going to be great!</title></head><body><div id="phenomic"><div class="BQq3Y" data-reactroot="" data-reactid="1" data-react-checksum="1867182936"><!-- react-empty: 2 --><!-- react-empty: 3 --><style data-reactid="4">@-ms-viewport { width: device-width; }</style><header class="_1xV8A" data-reactid="5"><nav class="_1G2C6" data-reactid="6"><div class="_3ScMt" data-reactid="7"><a class="_2Dqnn" href="/blog/" data-reactid="8">Kai Hao&#x27;s Blog</a></div><div class="_11SHU" data-reactid="9"><!-- react-text: 10 --><!-- /react-text --><a href="https://github.com/kevin940726/blog" target="_blank" class="_2Dqnn" data-reactid="11"><span class="SVGInline" data-reactid="12"><svg class="SVGInline-svg" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.238 1.84 1.238 1.07 1.834 2.806 1.304 3.49.997.108-.776.42-1.306.763-1.605-2.665-.305-5.467-1.334-5.467-5.93 0-1.312.47-2.382 1.236-3.222-.125-.303-.536-1.524.116-3.176 0 0 1.008-.322 3.3 1.23A11.51 11.51 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.29-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.236 1.91 1.236 3.22 0 4.61-2.807 5.625-5.48 5.922.43.372.824 1.102.824 2.222v3.293c0 .32.192.694.8.576C20.567 21.796 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></span><!-- react-text: 13 -->GitHub<!-- /react-text --></a></div></nav></header><div class="_1jOjL" data-reactid="14"><div data-reactid="15"><div class="_3APIs" data-reactid="16"><!-- react-empty: 17 --><h1 data-reactid="18">I Promise you, it&#x27;s going to be great!</h1><header class="_1-LPx" data-reactid="19"><time data-reactid="20">2016/03/22</time></header><div class="_3VLPm" data-reactid="21"><div data-reactid="22"><div class="phenomic-BodyContainer" data-reactid="23"><p><strong>Promise</strong> 是一個 ES6 JavaScript 中的新功能，雖然瀏覽器尚未全部支援，但其實早在很久以前就已經被非常多人使用，除了知名的 <a href="http://bluebirdjs.com/docs/getting-started.html">bluebird</a> 套件以外，早在 jQuery 時就已經有人使用了，這篇文章會小小介紹 Promise 在 js 中的應用以及它解決的問題。</p>
<h2 id="prerequirement"><a href="#prerequirement" class="phenomic-HeadingAnchor">#</a>Prerequirement</h2>
<ul>
<li>基本 JavaScript</li>
<li>callback function 應用</li>
<li>基本 jQuery 的 ajax get 用法</li>
</ul>
<hr>
<h2 id="problem"><a href="#problem" class="phenomic-HeadingAnchor">#</a>Problem</h2>
<p>相信稍微有寫過幾次 js 的人都知道 js 是一個 asynchronous 的語言，意味著在處理需要等待時間的程式碼時是非同步的，各個 function 在過程中彼此獨立，誰也不等待誰。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make2</span>(<span class="hljs-params">x</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        x = <span class="hljs-number">2</span>;
    }, <span class="hljs-number">1000</span>);

    <span class="hljs-keyword">return</span> x;
}

<span class="hljs-built_in">console</span>.log(make2(x)); <span class="hljs-comment">// 1</span></code></pre>
<p>那我們要怎麼知道某個事件處理完了再換人執行呢？在以往我們一般都是用 <code>callback</code> function 來幫我們處理這件事，以上面的例子為例，我們可以改寫成這樣：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make2</span>(<span class="hljs-params">x, callback</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        x = <span class="hljs-number">2</span>;
        callback(x);
    }, <span class="hljs-number">1000</span>);
}

make2(x, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 2</span>
});</code></pre>
<p>把需要回傳的值放在最後的 callback function 中引用就可以得到預期的結果了，以上都是很簡單很基本的處理方式，事實上其實也是非常完整的解決方案，一般幾乎所有的需求都可以靠 callback 解決，那我們為什麼還需要學 Promise 呢？</p>
<p>假如我們今天要去爬某個相簿網站的 api，要先拿出最近一本相簿的 <code>album_id</code> ，再用相簿的 <code>album_id</code> 拿出該相簿的第一張相片，假設該網站有一個 api 可以拿出相簿的 <code>album_id</code>，另外一個 api 可以透過傳入的 <code>album_id</code> 拿到第一張相片的 <code>photo_id</code>，那我們可以這樣寫。</p>
<pre><code class="hljs language-js">$.get(GET_LATEST_ALBUM_API, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">album_id</span>) </span>{
    $.get(GET_FIRST_PHOTO_API + album_id, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">photo_id</span>) </span>{
        <span class="hljs-comment">// the first photo in the latest album</span>
    });
});</code></pre>
<p>嗯⋯⋯看起來沒什麼問題呀？那⋯⋯如果我們現在想要拿該相片的拍攝者，還有那個人的名字，還有他的大頭貼，又這個網站對於所有的需求都獨立開另外一個 api ，而且還是一層一層的疊下去的。意思是我要得到相片的 <code>photo_id</code> 才可以得到拍攝者的 <code>user_id</code>，要得到拍攝者的 <code>user_id</code> 才可以得到他的名字，而又要有名字才可以得到他的大頭貼⋯⋯，先不討論什麼奇怪的 api 會這樣設計，那我們可能也會覺得說：「那又怎樣？我會寫啊！」，於是⋯⋯</p>
<pre><code class="hljs language-js">$.get(GET_LATEST_ALBUM_API, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">album_id</span>) </span>{
    $.get(GET_FIRST_PHOTO_API + album_id, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">photo_id</span>) </span>{
        $.get(GET_AUTHOR_API + photo_id, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user_id</span>) </span>{
            $.get(GET_USER_NAME_API + user_id, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user_name</span>) </span>{
                $.get(GET_USER_PHOTO_API + user_name, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user_photo</span>) </span>{
                    <span class="hljs-comment">// FINALLY!</span>
                });
            });
        });
    });
});</code></pre>
<p>天啊怎麼一層一層疊下去啊，好像不在寫 code，在玩疊疊樂了，如果要做的判斷和處理更多，或是又要再往下去呼叫 api 時光是看到 code 就快暈倒了吧！而這就是惡名昭彰的 <strong>callback hell</strong>，顧名思義就是一個天殺的地獄，所有人在寫 callback 時最討厭遇到這樣的問題了吧！</p>
<p>這個時候救世主 <strong>Promise</strong> 老大哥就出來跟小弟 callback 說：「欸欸小子，吃不消了吧？讓我來救救你吧！」，於是 callback 就哭著跑去抱住 Promise 然後一邊擦淚一邊責怪你的 code 寫得不好讓它進入地獄了。</p>
<h2 id="introducing-promise"><a href="#introducing-promise" class="phenomic-HeadingAnchor">#</a>Introducing Promise</h2>
<p>Promise 是什麼呢？我們知道了它要解決的問題可是還是對它完全不了解，其實 Promise 直翻就是<strong>保證</strong>，記住這個原則，<strong>它就是用來保證事件一定會完成的方法</strong>。還是不懂嗎？讓我們用 Promise 重新寫一次上面的例子。</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// jQuery 的 get method 可以無痛轉換成 Promise 寫法</span>

$.get(GET_LATEST_ALBUM_API)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">album_id</span>) </span>{
        <span class="hljs-keyword">return</span> $.get(GET_FIRST_PHOTO_API + album_id);
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">photo_id</span>) </span>{
        <span class="hljs-keyword">return</span> $.get(GET_AUTHOR_API + photo_id);
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user_id</span>) </span>{
        <span class="hljs-keyword">return</span> $.get(GET_USER_NAME_API + user_id);
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user_name</span>) </span>{
        <span class="hljs-keyword">return</span> $.get(GET_USER_PHOTO_API + user_name);
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user_photo</span>) </span>{
        <span class="hljs-comment">// WE DID IT!</span>
    });</code></pre>
<p>天啊傑克～這真是太神奇啦～～～，<strong>Promise</strong> 的<strong>保證</strong>真的很有信用耶！比所有台灣的政客都還要值得信賴呢！</p>
<p>看完了基本的 Promise 應用，讓我們再回來看看 Promise 背後的原理和用法。</p>
<p>Promise 是一個 object，在創造一個新的 Promise 時他吃一個 function，而這個 function 各吃兩個 function，第一個是 Promise 完成時的 callback，第二個則是失敗(拒絕)時的 callback。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">var</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            x = <span class="hljs-number">2</span>;
            resolve(x);
        }, <span class="hljs-number">1000</span>);
    }
);</code></pre>
<p>新建完的 Promise 就會有兩個 method 可以使用，一個是 <code>then()</code> 代表 Promise 成功時執行的 callback，第二個是 <code>catch()</code> 代表失敗時的 callback。</p>
<p>而 <code>then()</code> function也可以吃兩個 callback 參數，第一個是成功時的，第二個也自然是失敗的。</p>
<pre><code class="hljs language-js">myPromise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 2</span>
}, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// rejected</span>
});</code></pre>
<p>在 <code>then()</code> function 中也是可以回傳值的，你可以回傳一個簡單的值或是回傳另一個 Promise，而回傳後的值可以一直 chain 連鎖下去，一直 then then then⋯⋯直到最後。</p>
<pre><code class="hljs language-js">myPromise
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>; <span class="hljs-comment">// return simple value</span>
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
        <span class="hljs-keyword">return</span> anotherPromise(x); <span class="hljs-comment">// return another Promise</span>
    })
    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
        <span class="hljs-comment">// catch error at the end, any error happened above will be rejected into here.</span>
    });</code></pre>
<p>就這樣簡單的一些 method 就可以開始自己新建一個 Promise 了，運用一些 higher-order function 的技巧可以建立可重複使用的 Promise function，例如我們練習把原本 jQuery 的 get callback function 改寫成 Promise 的方法。</p>
<pre><code class="hljs language-js">$.prototype.getPromise = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(
        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
            $.get(url, resolve);
        }
    );
};

$.getPromise(url)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{
        <span class="hljs-built_in">console</span>.log(response);
    })
    .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{
        <span class="hljs-built_in">console</span>.log(reason);
    });</code></pre>
<p>不過其實鮮少會有機會需要自己建立這樣的 Promise function，大部分都直接使用現成的套件，包括 jQuery 和 bluebird 以外，原生的瀏覽器也有部分支援了 Promise 的基本用法，若是要向下支援的話我推薦直接使用跨瀏覽器的 <a href="https://github.com/taylorhakes/promise-polyfill">polyfill</a>，假如不需要使用一些特殊的功能的話，輕量的 polyfill 就已經很夠用了，若只是內部使用或是只是在測試的話在 modern browser 上都已經支援了，直接使用就可以了。</p>
<h2 id="more-examples"><a href="#more-examples" class="phenomic-HeadingAnchor">#</a>More Examples</h2>
<p>基本上 Promise 的使用方式真的很簡單，沒有太多神奇的用法，照著上面的一些範例就可以處理大部分的問題了，不過有時候還是會有一些情況是需要多依靠一些方法的。</p>
<p>假如我們把上面拿相簿 api 的例子改變一下，這次我們不拿最近一本相簿的第一張相片了，我們要拿全部的相簿以及他們各自的全部的相片，這次我也不只拿拍攝者一個人了，我要拿的是所有按這張相片喜歡的所有人，以及他們各自所有的名字和大頭貼，一般直覺上我們可能一開始會這麼寫。</p>
<pre><code class="hljs language-js">$.get(GET_ALL_ALBUM_API)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">albums</span>) </span>{
        albums.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">album_id</span>) </span>{
            $.get(GET_ALL_PHOTO_API + album_id)
                .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">photos</span>) </span>{
                    photos.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">photo_id</span>) </span>{
                        <span class="hljs-comment">// ...</span>
                        <span class="hljs-comment">// you get the point...</span>
                    });
                });
        });
    });</code></pre>
<p>這個簡單的例子可以發現一般 Promise 在處理 list 的時候還是不太順暢的，一旦出現了 list 就破壞了原本
chain 的結構，寫出來的 code 就跟他的小弟 callback hell 一樣了。</p>
<p>那是不是就代表這種情況 Promise 也無用武之地？當然不是囉～不然這篇就不會是在介紹 Promise 了，不是說過我<strong>保證</strong>會做好做滿的嗎？其實解決方法很簡單，我們不一個一個<strong>保證</strong>單一個政策了，我們<strong>全部保證</strong>做到，絕對不跳票！超級P來拯救咧～</p>
<h3 id="promiseall"><a href="#promiseall" class="phenomic-HeadingAnchor">#</a>Promise.all()</h3>
<pre><code class="hljs language-js">$.get(GET_ALL_ALBUM_API)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">albums</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(albums.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">album.id</span>) </span>{
            <span class="hljs-keyword">return</span> $.get(GET_ALL_PHOTO_API + album_id);
        }));
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">photos</span>) </span>{
        <span class="hljs-built_in">console</span>.log(photos);
        <span class="hljs-comment">// [</span>
        <span class="hljs-comment">//     [album1_photo1, album1_photo2, ...],</span>
        <span class="hljs-comment">//     [album2_photo1, album2_photo2, ...],</span>
        <span class="hljs-comment">//     ...</span>
        <span class="hljs-comment">// ]</span>
    });</code></pre>
<p><code>Promise.all()</code> 吃一個 array 當作參數，array 中的每個值都是 Promise，形成一個 list of Promise 的概念，最後也會確保每個 Promise 都完成了以後才進入 <code>then()</code> function，以上面的例子來說我先將各個 <code>album_id</code> 代入 Promise function 透過 <code>map()</code> 得到一個 Promise 的 Array，將它們餵給 <code>Promise.all()</code> 後就會得到一個大的
Promise 大哥大，在最後 <code>return</code> 它後就可以繼續利用 <code>then()</code> chain 下去了，之後的做法也都依此類推，最後就可以拿到一個非常大的 Array 裡面包含了所有的相簿、所有的相片、所有的按喜歡的人以及他們各自的名字和大頭貼了。</p>
<hr>
<p>Promise 是不是很簡單又很方便呀～在下一個專案上練習使用看看吧！</p>
</div></div></div></div></div></div><footer class="_2z9l6" data-reactid="24"><!-- react-text: 25 -->Powered by <!-- /react-text --><a target="_blank" href="https://github.com/MoOx/phenomic#readme" class="tCyG5" data-reactid="26"><span data-reactid="27">&lt;Phenomic /&gt;</span></a><!-- react-text: 28 --> | <!-- /react-text --><!-- react-text: 29 -->© 2016 Kai Hao, unless otherwise noted.<!-- /react-text --></footer></div></div><script>window.__COLLECTION__ = [{"title":"","metaTitle":"Kai Hao's Blog","layout":"Homepage","description":"","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.41216a2f9e87f1859056a5c9aa75c589.json"},{"layout":"PageError","route":"404.html","description":"Content here not used, see web_modules/layouts/PageError","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.f3d82a4d938b593823c37ead979b3b86.json"},{"layout":"PageLoading","description":"Content here not used, see web_modules/layouts/PageLoading. This page is a demo for loading state. You can safely delete if you want.","__filename":"loading.md","__url":"/loading/","__resourceUrl":"/loading/index.html","__dataUrl":"/loading/index.html.4f959959ceecdafbb30e2e8fd2869cdc.json"},{"title":"Holy Babel! Praise the ES6 Harmony.","layout":"Post","date":"2016-03-24T16:04:28.000Z","tags":"JavaScript","description":"ECMAScript6 簡稱 ES6 或 ES2015 是 JavaScript 在 2015 年的最新進化，從前 js 都常被開發者們調侃是一個不好的語言，現在雖然當然還不夠好，但在持續的進化的過程中，每年推出新的 spec 的進度應該過不了多久就會成為超夢了吧～ ES6","__filename":"posts/Holy-Babel-Praise-the-ES6-Harmony.md","__url":"/posts/Holy-Babel-Praise-the-ES6-Harmony/","__resourceUrl":"/posts/Holy-Babel-Praise-the-ES6-Harmony/index.html","__dataUrl":"/posts/Holy-Babel-Praise-the-ES6-Harmony/index.html.c3489ec79d739f733fe1ef80849e1b65.json"},{"title":"I Promise you, it's going to be great!","layout":"Post","date":"2016-03-22T14:15:05.000Z","tags":"JavaScript","description":"Promise 是一個 ES6 JavaScript 中的新功能，雖然瀏覽器尚未全部支援，但其實早在很久以前就已經被非常多人使用，除了知名的 bluebird 套件以外，早在 jQuery 時就已經有人使用了，這篇文章會小小介紹 Promise 在 js","__filename":"posts/I-Promise-you-it-s-going-to-be-great.md","__url":"/posts/I-Promise-you-it-s-going-to-be-great/","__resourceUrl":"/posts/I-Promise-you-it-s-going-to-be-great/index.html","__dataUrl":"/posts/I-Promise-you-it-s-going-to-be-great/index.html.7f41271a04cf7b2f988ffa71381651dc.json"}];window.__INITIAL_STATE__ = {"pages":{"/posts/I-Promise-you-it-s-going-to-be-great/":{"head":{"title":"I Promise you, it's going to be great!","layout":"Post","date":"2016-03-22T14:15:05.000Z","tags":"JavaScript","description":"Promise 是一個 ES6 JavaScript 中的新功能，雖然瀏覽器尚未全部支援，但其實早在很久以前就已經被非常多人使用，除了知名的 bluebird 套件以外，早在 jQuery 時就已經有人使用了，這篇文章會小小介紹 Promise 在 js"},"body":"<p><strong>Promise</strong> 是一個 ES6 JavaScript 中的新功能，雖然瀏覽器尚未全部支援，但其實早在很久以前就已經被非常多人使用，除了知名的 <a href=\"http://bluebirdjs.com/docs/getting-started.html\">bluebird</a> 套件以外，早在 jQuery 時就已經有人使用了，這篇文章會小小介紹 Promise 在 js 中的應用以及它解決的問題。</p>\n<h2 id=\"prerequirement\"><a href=\"#prerequirement\" class=\"phenomic-HeadingAnchor\">#</a>Prerequirement</h2>\n<ul>\n<li>基本 JavaScript</li>\n<li>callback function 應用</li>\n<li>基本 jQuery 的 ajax get 用法</li>\n</ul>\n<hr>\n<h2 id=\"problem\"><a href=\"#problem\" class=\"phenomic-HeadingAnchor\">#</a>Problem</h2>\n<p>相信稍微有寫過幾次 js 的人都知道 js 是一個 asynchronous 的語言，意味著在處理需要等待時間的程式碼時是非同步的，各個 function 在過程中彼此獨立，誰也不等待誰。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">make2</span>(<span class=\"hljs-params\">x</span>) </span>{\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        x = <span class=\"hljs-number\">2</span>;\n    }, <span class=\"hljs-number\">1000</span>);\n\n    <span class=\"hljs-keyword\">return</span> x;\n}\n\n<span class=\"hljs-built_in\">console</span>.log(make2(x)); <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>那我們要怎麼知道某個事件處理完了再換人執行呢？在以往我們一般都是用 <code>callback</code> function 來幫我們處理這件事，以上面的例子為例，我們可以改寫成這樣：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">make2</span>(<span class=\"hljs-params\">x, callback</span>) </span>{\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        x = <span class=\"hljs-number\">2</span>;\n        callback(x);\n    }, <span class=\"hljs-number\">1000</span>);\n}\n\nmake2(x, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(x); <span class=\"hljs-comment\">// 2</span>\n});</code></pre>\n<p>把需要回傳的值放在最後的 callback function 中引用就可以得到預期的結果了，以上都是很簡單很基本的處理方式，事實上其實也是非常完整的解決方案，一般幾乎所有的需求都可以靠 callback 解決，那我們為什麼還需要學 Promise 呢？</p>\n<p>假如我們今天要去爬某個相簿網站的 api，要先拿出最近一本相簿的 <code>album_id</code> ，再用相簿的 <code>album_id</code> 拿出該相簿的第一張相片，假設該網站有一個 api 可以拿出相簿的 <code>album_id</code>，另外一個 api 可以透過傳入的 <code>album_id</code> 拿到第一張相片的 <code>photo_id</code>，那我們可以這樣寫。</p>\n<pre><code class=\"hljs language-js\">$.get(GET_LATEST_ALBUM_API, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">album_id</span>) </span>{\n    $.get(GET_FIRST_PHOTO_API + album_id, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">photo_id</span>) </span>{\n        <span class=\"hljs-comment\">// the first photo in the latest album</span>\n    });\n});</code></pre>\n<p>嗯⋯⋯看起來沒什麼問題呀？那⋯⋯如果我們現在想要拿該相片的拍攝者，還有那個人的名字，還有他的大頭貼，又這個網站對於所有的需求都獨立開另外一個 api ，而且還是一層一層的疊下去的。意思是我要得到相片的 <code>photo_id</code> 才可以得到拍攝者的 <code>user_id</code>，要得到拍攝者的 <code>user_id</code> 才可以得到他的名字，而又要有名字才可以得到他的大頭貼⋯⋯，先不討論什麼奇怪的 api 會這樣設計，那我們可能也會覺得說：「那又怎樣？我會寫啊！」，於是⋯⋯</p>\n<pre><code class=\"hljs language-js\">$.get(GET_LATEST_ALBUM_API, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">album_id</span>) </span>{\n    $.get(GET_FIRST_PHOTO_API + album_id, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">photo_id</span>) </span>{\n        $.get(GET_AUTHOR_API + photo_id, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">user_id</span>) </span>{\n            $.get(GET_USER_NAME_API + user_id, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">user_name</span>) </span>{\n                $.get(GET_USER_PHOTO_API + user_name, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">user_photo</span>) </span>{\n                    <span class=\"hljs-comment\">// FINALLY!</span>\n                });\n            });\n        });\n    });\n});</code></pre>\n<p>天啊怎麼一層一層疊下去啊，好像不在寫 code，在玩疊疊樂了，如果要做的判斷和處理更多，或是又要再往下去呼叫 api 時光是看到 code 就快暈倒了吧！而這就是惡名昭彰的 <strong>callback hell</strong>，顧名思義就是一個天殺的地獄，所有人在寫 callback 時最討厭遇到這樣的問題了吧！</p>\n<p>這個時候救世主 <strong>Promise</strong> 老大哥就出來跟小弟 callback 說：「欸欸小子，吃不消了吧？讓我來救救你吧！」，於是 callback 就哭著跑去抱住 Promise 然後一邊擦淚一邊責怪你的 code 寫得不好讓它進入地獄了。</p>\n<h2 id=\"introducing-promise\"><a href=\"#introducing-promise\" class=\"phenomic-HeadingAnchor\">#</a>Introducing Promise</h2>\n<p>Promise 是什麼呢？我們知道了它要解決的問題可是還是對它完全不了解，其實 Promise 直翻就是<strong>保證</strong>，記住這個原則，<strong>它就是用來保證事件一定會完成的方法</strong>。還是不懂嗎？讓我們用 Promise 重新寫一次上面的例子。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// jQuery 的 get method 可以無痛轉換成 Promise 寫法</span>\n\n$.get(GET_LATEST_ALBUM_API)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">album_id</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> $.get(GET_FIRST_PHOTO_API + album_id);\n    })\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">photo_id</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> $.get(GET_AUTHOR_API + photo_id);\n    })\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">user_id</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> $.get(GET_USER_NAME_API + user_id);\n    })\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">user_name</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> $.get(GET_USER_PHOTO_API + user_name);\n    })\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">user_photo</span>) </span>{\n        <span class=\"hljs-comment\">// WE DID IT!</span>\n    });</code></pre>\n<p>天啊傑克～這真是太神奇啦～～～，<strong>Promise</strong> 的<strong>保證</strong>真的很有信用耶！比所有台灣的政客都還要值得信賴呢！</p>\n<p>看完了基本的 Promise 應用，讓我們再回來看看 Promise 背後的原理和用法。</p>\n<p>Promise 是一個 object，在創造一個新的 Promise 時他吃一個 function，而這個 function 各吃兩個 function，第一個是 Promise 完成時的 callback，第二個則是失敗(拒絕)時的 callback。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-keyword\">var</span> myPromise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n            x = <span class=\"hljs-number\">2</span>;\n            resolve(x);\n        }, <span class=\"hljs-number\">1000</span>);\n    }\n);</code></pre>\n<p>新建完的 Promise 就會有兩個 method 可以使用，一個是 <code>then()</code> 代表 Promise 成功時執行的 callback，第二個是 <code>catch()</code> 代表失敗時的 callback。</p>\n<p>而 <code>then()</code> function也可以吃兩個 callback 參數，第一個是成功時的，第二個也自然是失敗的。</p>\n<pre><code class=\"hljs language-js\">myPromise.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(x); <span class=\"hljs-comment\">// 2</span>\n}, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// rejected</span>\n});</code></pre>\n<p>在 <code>then()</code> function 中也是可以回傳值的，你可以回傳一個簡單的值或是回傳另一個 Promise，而回傳後的值可以一直 chain 連鎖下去，一直 then then then⋯⋯直到最後。</p>\n<pre><code class=\"hljs language-js\">myPromise\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// return simple value</span>\n    })\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> anotherPromise(x); <span class=\"hljs-comment\">// return another Promise</span>\n    })\n    .catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>{\n        <span class=\"hljs-comment\">// catch error at the end, any error happened above will be rejected into here.</span>\n    });</code></pre>\n<p>就這樣簡單的一些 method 就可以開始自己新建一個 Promise 了，運用一些 higher-order function 的技巧可以建立可重複使用的 Promise function，例如我們練習把原本 jQuery 的 get callback function 改寫成 Promise 的方法。</p>\n<pre><code class=\"hljs language-js\">$.prototype.getPromise = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">url</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>{\n            $.get(url, resolve);\n        }\n    );\n};\n\n$.getPromise(url)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">response</span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(response);\n    })\n    .catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">reason</span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(reason);\n    });</code></pre>\n<p>不過其實鮮少會有機會需要自己建立這樣的 Promise function，大部分都直接使用現成的套件，包括 jQuery 和 bluebird 以外，原生的瀏覽器也有部分支援了 Promise 的基本用法，若是要向下支援的話我推薦直接使用跨瀏覽器的 <a href=\"https://github.com/taylorhakes/promise-polyfill\">polyfill</a>，假如不需要使用一些特殊的功能的話，輕量的 polyfill 就已經很夠用了，若只是內部使用或是只是在測試的話在 modern browser 上都已經支援了，直接使用就可以了。</p>\n<h2 id=\"more-examples\"><a href=\"#more-examples\" class=\"phenomic-HeadingAnchor\">#</a>More Examples</h2>\n<p>基本上 Promise 的使用方式真的很簡單，沒有太多神奇的用法，照著上面的一些範例就可以處理大部分的問題了，不過有時候還是會有一些情況是需要多依靠一些方法的。</p>\n<p>假如我們把上面拿相簿 api 的例子改變一下，這次我們不拿最近一本相簿的第一張相片了，我們要拿全部的相簿以及他們各自的全部的相片，這次我也不只拿拍攝者一個人了，我要拿的是所有按這張相片喜歡的所有人，以及他們各自所有的名字和大頭貼，一般直覺上我們可能一開始會這麼寫。</p>\n<pre><code class=\"hljs language-js\">$.get(GET_ALL_ALBUM_API)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">albums</span>) </span>{\n        albums.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">album_id</span>) </span>{\n            $.get(GET_ALL_PHOTO_API + album_id)\n                .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">photos</span>) </span>{\n                    photos.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">photo_id</span>) </span>{\n                        <span class=\"hljs-comment\">// ...</span>\n                        <span class=\"hljs-comment\">// you get the point...</span>\n                    });\n                });\n        });\n    });</code></pre>\n<p>這個簡單的例子可以發現一般 Promise 在處理 list 的時候還是不太順暢的，一旦出現了 list 就破壞了原本\nchain 的結構，寫出來的 code 就跟他的小弟 callback hell 一樣了。</p>\n<p>那是不是就代表這種情況 Promise 也無用武之地？當然不是囉～不然這篇就不會是在介紹 Promise 了，不是說過我<strong>保證</strong>會做好做滿的嗎？其實解決方法很簡單，我們不一個一個<strong>保證</strong>單一個政策了，我們<strong>全部保證</strong>做到，絕對不跳票！超級P來拯救咧～</p>\n<h3 id=\"promiseall\"><a href=\"#promiseall\" class=\"phenomic-HeadingAnchor\">#</a>Promise.all()</h3>\n<pre><code class=\"hljs language-js\">$.get(GET_ALL_ALBUM_API)\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">albums</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(albums.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">album.id</span>) </span>{\n            <span class=\"hljs-keyword\">return</span> $.get(GET_ALL_PHOTO_API + album_id);\n        }));\n    })\n    .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">photos</span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(photos);\n        <span class=\"hljs-comment\">// [</span>\n        <span class=\"hljs-comment\">//     [album1_photo1, album1_photo2, ...],</span>\n        <span class=\"hljs-comment\">//     [album2_photo1, album2_photo2, ...],</span>\n        <span class=\"hljs-comment\">//     ...</span>\n        <span class=\"hljs-comment\">// ]</span>\n    });</code></pre>\n<p><code>Promise.all()</code> 吃一個 array 當作參數，array 中的每個值都是 Promise，形成一個 list of Promise 的概念，最後也會確保每個 Promise 都完成了以後才進入 <code>then()</code> function，以上面的例子來說我先將各個 <code>album_id</code> 代入 Promise function 透過 <code>map()</code> 得到一個 Promise 的 Array，將它們餵給 <code>Promise.all()</code> 後就會得到一個大的\nPromise 大哥大，在最後 <code>return</code> 它後就可以繼續利用 <code>then()</code> chain 下去了，之後的做法也都依此類推，最後就可以拿到一個非常大的 Array 裡面包含了所有的相簿、所有的相片、所有的按喜歡的人以及他們各自的名字和大頭貼了。</p>\n<hr>\n<p>Promise 是不是很簡單又很方便呀～在下一個專案上練習使用看看吧！</p>\n","__filename":"posts/I-Promise-you-it-s-going-to-be-great.md","__url":"/posts/I-Promise-you-it-s-going-to-be-great/","__resourceUrl":"/posts/I-Promise-you-it-s-going-to-be-great/index.html","__dataUrl":"/posts/I-Promise-you-it-s-going-to-be-great/index.html.7f41271a04cf7b2f988ffa71381651dc.json","type":"Post"}}}</script><script data-react-helmet="true" src="https://cdn.polyfill.io/v2/polyfill.min.js"></script><script src="/blog/phenomic.browser.1fa6b69c27aa5b9c2471.js"></script></body></html>